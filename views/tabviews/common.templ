package tabviews

import (
	"fmt"
	"github.com/google/uuid"
	foodlib "FOOdBAR/FOOlib"
)

templ ColorsCSS() {
	<style type="text/css">
		@media (prefers-color-scheme: dark) {
			.bodycolors {
				border-color: white;
				background-color: #1e1e1f;
				color: white;
				fill: white;
				stroke: white;
			}
		}
		@media (not (prefers-color-scheme: dark)) {
			.bodycolors {
				border-color: black;
				background-color: lightgray;
				color: black;
				fill: black;
				stroke: black;
			}
		}
	</style>
}

templ OOBsendBackSubmitStatus(id uuid.UUID, message string, e error) {
	<div id={ fmt.Sprintf("itemSubmitMessage_%s", id.String()) } hx-swap-oob="true">
		@submitStatusMessage(id, message, e)
	</div>
}

templ submitStatusMessage(id uuid.UUID, message string, e error) {
	<div id={ fmt.Sprintf("itemSubmitMessage_%s", id.String()) }>
		<div class="text-green-500">
			{ message }
		</div>
		<div class="text-red-500">
			if e != nil {
				{ e.Error() }
			}
		</div>
	</div>
}

templ OOBExtraField(field string, itemid uuid.UUID) {
	<div id={ string(templ.URL(fmt.Sprintf("%s_edit_%s", field, itemid.String()))) } hx-swap-oob="beforeend">
		@ExtraField("", field, itemid)
	</div>
}

// NOTE:
// The first line of hyperscript is just an event possibly used later for undo
// The rest gives each new field a unique ID and was fun
templ ExtraField(val string, field string, itemid uuid.UUID) {
	<input
		_="on input trigger reactiveInputEvent(value: (value of me), id: @id) end

			on load put the children of the closest parent <div /> into myList
			then for item in myList indexed by i
			if the item's index does not exist
			set the item's index to i
			then set the item's id to item's id + '_' + i

			/* yes i edited hyperscript JUST for indexed by instead of index */
		"
		class="text-black"
		type="text"
		id={ fmt.Sprintf("%s_%s", templ.URL(field), itemid.String()) }
		name={ fmt.Sprintf("%s[]", templ.URL(field)) }
		value={ val }
	/>
}

templ RenderSubmissionContent(pd *foodlib.PageData, item *foodlib.TabItem, msg string, e error) {
	switch item.Ttype {
		case foodlib.Recipe:
			@SubmitRecipeBlock(pd, item, msg, e)
		case foodlib.Pantry:
			@SubmitPantryBlock(pd, item, msg, e)
		case foodlib.Menu:
			@SubmitMenuBlock(pd, item, msg, e)
		case foodlib.Shopping:
			@SubmitShoppingBlock(pd, item, msg, e)
		case foodlib.Preplist:
			@SubmitPreplistBlock(pd, item, msg, e)
		case foodlib.Earnings:
			@SubmitEarningsBlock(pd, item, msg, e)
		case foodlib.Customer:
			@SubmitCustomerBlock(pd, item, msg, e)
		case foodlib.Events:
			@SubmitEventsBlock(pd, item, msg, e)
	}
}

templ RenderFlipSubmitContent(pd *foodlib.PageData, item *foodlib.TabItem, msg string, e error) {
	switch item.Ttype {
		case foodlib.Recipe:
			@SubmitRecipeBlock(pd, item, msg, e)
		case foodlib.Pantry:
			@SubmitPantryBlock(pd, item, msg, e)
		case foodlib.Menu:
			@SubmitMenuBlock(pd, item, msg, e)
		case foodlib.Shopping:
			@SubmitShoppingBlock(pd, item, msg, e)
		case foodlib.Preplist:
			@SubmitPreplistBlock(pd, item, msg, e)
		case foodlib.Earnings:
			@SubmitEarningsBlock(pd, item, msg, e)
		case foodlib.Customer:
			@SubmitCustomerBlock(pd, item, msg, e)
		case foodlib.Events:
			@SubmitEventsBlock(pd, item, msg, e)
	}
}

// NOTE: pass in a new TabData with only the new items, and to the real one in db, append the items.
templ MoreTabItems(pd *foodlib.PageData, td *foodlib.TabData, more bool) {
	switch td.Ttype {
		case foodlib.Recipe:
			for _, ti := range td.Items {
				@RecipeItemContainer(pd, td, ti)
			}
		case foodlib.Pantry:
			for _, ti := range td.Items {
				@PantryItemContainer(pd, td, ti)
			}
		case foodlib.Menu:
			for _, ti := range td.Items {
				@MenuItemContainer(pd, td, ti)
			}
		case foodlib.Shopping:
			for _, ti := range td.Items {
				@ShoppingItemContainer(pd, td, ti)
			}
		case foodlib.Preplist:
			for _, ti := range td.Items {
				@PreplistItemContainer(pd, td, ti)
			}
		case foodlib.Earnings:
			for _, ti := range td.Items {
				@EarningsItemContainer(pd, td, ti)
			}
		case foodlib.Customer:
			for _, ti := range td.Items {
				@CustomerItemContainer(pd, td, ti)
			}
		case foodlib.Events:
			for _, ti := range td.Items {
				@EventsItemContainer(pd, td, ti)
			}
	}
	if more {
		@GetNewMoreGetter(td.Ttype)
	}
}

templ GetNewMoreGetter(tt foodlib.TabType) {
	<div
		hx-trigger="revealed"
		hx-swap="outerHTML"
		hx-get={ fmt.Sprintf("%s/api/getMoreItems/%s", foodlib.PagePrefix, tt) }
	></div>
}

templ RenderTabContents(pd *foodlib.PageData, td *foodlib.TabData, firstRender bool) {
	switch td.Ttype {
		case foodlib.Recipe:
			@RenderRecipeTab(pd, td, firstRender)
		case foodlib.Pantry:
			@RenderPantryTab(pd, td, firstRender)
		case foodlib.Menu:
			@RenderMenuTab(pd, td, firstRender)
		case foodlib.Shopping:
			@RenderShoppingTab(pd, td, firstRender)
		case foodlib.Preplist:
			@RenderPreplistTab(pd, td, firstRender)
		case foodlib.Earnings:
			@RenderEarningsTab(pd, td, firstRender)
		case foodlib.Customer:
			@RenderCustomerTab(pd, td, firstRender)
		case foodlib.Events:
			@RenderEventsTab(pd, td, firstRender)
	}
}

// Load this as part of the main page
templ CardFlipContainerCSS() {
	<style type="text/css">
	.card_container {
		height: 100%;
		width: 100%;
		perspective: 600px;
	}
	.card {
		width: 100%;
		height: 100%;
		position: relative;
		transition: transform 0.5s;
		transform-style: preserve-3d;
	}
	.card__face {
		position: absolute;
		height: 100%;
		width: 100%;
		backface-visibility: hidden;
	}
	.card.flip-in {
		transform: rotateY(-180deg);
	}
	.card.flip-out {
		transform: rotateY(180deg);
	}
	.card__face--front {
		transform: rotateY(-180deg);
	}
	.card__face--back {
		transform: rotateY(180deg);
	}
	</style>
}

// requires above css to already be loaded (because otherwise we send it many many times)
templ CardFlipContainer(front templ.Component, back templ.Component) {
	<div class="card_container">
		<div
			class="card"
			if back == nil {
				_="on load add .flip-out to me"
			} else {
				_="on load add .flip-in to me"
			}
		>
			<div class="card__face card__face--front">
				if front != nil {
					@front
				}
			</div>
			<div class="card__face card__face--back">
				if back != nil {
					@back
				}
			</div>
		</div>
	</div>
}

// called by views/homepage.go during rendering or removing old tabs
// this div moved here because its counterpart OOB templates are here.
templ MainTabContents(pd *foodlib.PageData, td *foodlib.TabData) {
	<div
		id={ fmt.Sprintf("tabContainerTarget_%s", td.Ttype.String()) }
		class="flex self-stretch flex-col flex-auto flex-grow"
	>
		@RenderTabContents(pd, td, true)
	</div>
}

templ OOBflipTab(pd *foodlib.PageData, td *foodlib.TabData) {
	<div
		id={ fmt.Sprintf("tabContainerTarget_%s", td.Ttype.String()) }
		hx-swap-oob="innerHTML"
	>
		@RenderTabContents(pd, td, false)
	</div>
}

templ FlipEditTabItemButton(ti *foodlib.TabItem) {
	<div
		id={ fmt.Sprintf("ItemEdit_%s", ti.Ttype.String()) }
		hx-get={ fmt.Sprintf("%s/api/itemEditFlip/open/%s/%s", foodlib.PagePrefix, ti.Ttype.String(), ti.ItemID.String()) }
		hx-swap="none"
		class={ TabHeaderButtonCSS() }
	>
		@EditSVG()
	</div>
}

templ FlipAddItemButton(tt foodlib.TabType) {
	<div
		id={ fmt.Sprintf("tabItemAdd_%s", tt.String()) }
		hx-get={ fmt.Sprintf("%s/api/itemCreateFlip/open/%s", foodlib.PagePrefix, tt.String()) }
		hx-swap="none"
		class={ TabHeaderButtonCSS() }
	>
		@AddCircle()
	</div>
}

templ CloseFlipButton(tt foodlib.TabType) {
	<div
		id={ fmt.Sprintf("tabItemAdd_%s", tt.String()) }
		hx-get={ fmt.Sprintf("%s/api/itemEditFlip/close/%s", foodlib.PagePrefix, tt.String()) }
		hx-swap="none"
		class={ TabHeaderButtonCSS() }
	>
		@MinusCircle()
	</div>
}

css TabHeaderButtonCSS() {
	display: flex;
	flex-direction: row;
	margin: 3px;
	flex: 0 0 1.5rem;
	cursor: pointer;
}

templ MaximizeTabButton(tt foodlib.TabType) {
	<div
		id={ fmt.Sprintf("tabButton_%s", tt) }
		hx-post={ fmt.Sprintf("%s/api/tabButton/maximize/%s", foodlib.PagePrefix, tt) }
		hx-target="#tabViewContainer"
		class={ TabHeaderButtonCSS() }
	>
		@Maximize()
	</div>
}

templ ModalAddItemButton(tt foodlib.TabType) {
	<div
		id={ fmt.Sprintf("tabItemAdd_%s", tt.String()) }
		hx-get={ fmt.Sprintf("%s/api/itemCreateModal/open/%s", foodlib.PagePrefix, tt.String()) }
		hx-swap="beforeend"
		hx-target="body"
		class={ TabHeaderButtonCSS() }
	>
		@AddCircle()
	</div>
}

templ ModalEditTabItemButton(ti *foodlib.TabItem) {
	<div
		id={ fmt.Sprintf("ItemEdit_%s", ti.Ttype.String()) }
		hx-get={ fmt.Sprintf("%s/api/itemEditModal/open/%s/%s", foodlib.PagePrefix, ti.Ttype.String(), ti.ItemID.String()) }
		hx-swap="beforeend"
		hx-target="body"
		class={ TabHeaderButtonCSS() }
	>
		@EditSVG()
	</div>
}

templ ModalCSS() {
	<style type="text/css">
		/***** MODAL DIALOG ****/
		#modal {
			/* Underlay covers entire screen. */
			position: fixed;
			top:0px;
			bottom: 0px;
			left:0px;
			right:0px;
			z-index:1000;

			/* Flexbox centers the .modal-content vertically and horizontally */
			display:flex;
			flex-direction:column;
			align-items:center;

			/* Animate when opening */
			animation-name: fadeIn;
			animation-duration:150ms;
			animation-timing-function: ease;
		}

		#modal > .modal-underlay {
			/* underlay takes up the entire viewport. This is only
			required if you want to click to dismiss the popup */
			background-color:rgba(0,0,0,0.5);
			position: absolute;
			z-index: -1;
			top:0px;
			bottom:0px;
			left: 0px;
			right: 0px;
		}

		#modal > .modal-content {
			/* Position visible dialog near the top of the window */
			margin-top:10vh;

			/* Sizing for visible dialog */
			width:80%;
			max-width:600px;

			/* Display properties for visible dialog*/
			border:solid 1px;
			border-radius:8px;
			box-shadow: 0px 0px 20px 0px rgba(0,0,0,0.3);
			padding:20px;

			/* Animate when opening */
			animation-name:zoomIn;
			animation-duration:150ms;
			animation-timing-function: ease;
		}

		#modal.closing {
			/* Animate when closing */
			animation-name: fadeOut;
			animation-duration:150ms;
			animation-timing-function: ease;
		}

		#modal.closing > .modal-content {
			/* Animate when closing */
			animation-name: zoomOut;
			animation-duration:150ms;
			animation-timing-function: ease;
		}

		@keyframes fadeIn {
			0% {opacity: 0;}
			100% {opacity: 1;}
		} 

		@keyframes fadeOut {
			0% {opacity: 1;}
			100% {opacity: 0;}
		} 

		@keyframes zoomIn {
			0% {transform: scale(0.9);}
			100% {transform: scale(1);}
		} 

		@keyframes zoomOut {
			0% {transform: scale(1);}
			100% {transform: scale(0.9);}
		} 
	</style>
}

// requires above css to already be loaded (because otherwise we send it many many times)
templ ItemEditModal(component templ.Component) {
	<div id="modal" _="on closeModal add .closing then wait for animationend then remove me">
		<div class="modal-underlay" _="on click trigger closeModal"></div>
		<div class="modal-content bodycolors">
			@component
		</div>
	</div>
}
